---
layout: post
title: Functional Programming in R 
subtitle: 
date: 2019-01-03 12:00:00
author: John 
meta: "Tutorials"
tags: mix Advanced 
---

<div class="block">
  <center><img src="{{ site.baseurl }}/img/tutheader-func-prog.png" alt="Img"></center>
</div>

### Tutorial aims:

#### <a href="#introduction"> 1. What is functional programming</a>

#### <a href="#function"> 2. Building a simple function</a>

#### <a href="#loop"> 3. Functions in loops</a>

#### <a href="#apply"> 4. Functions with `lapply`</a>

#### <a href="#ifelse"> 5. Conditional statements</a>

#### <a href="#debug"> 6. Debugging functions</a>

All the resources for this tutorial, including some useful extra reading can be downloaded from <a href="https://github.com/ourcodingclub/CC-func-prog" target="_blank">this Github repository</a>. Clone and download the repo as a zipfile, then unzip it.

Next, open up a new R Script, preferably in RStudio, where you will write the code for this tutorial. Set the folder you just downloaded as your working directory by running the code below (replacing `PATH_TO_FOLDER` with the location of the folder on your computer, e.g. `~/Downloads/CC-func-prog-master`):

```r
setwd("PATH_TO_FOLDER")
```

<a name="introduction"></a>

## 1. What is Functional Programming

In <a href="https://ourcodingclub.github.io/2017/02/08/funandloops.html" target="_blank">a previous workshop</a> we introduced the concept of functions and loops in R. We showed how they can be used to minimise the need to copy and paste chunks of code, helping to make your code more readable and minimise the chance of making mistakes by manually retyping code.This workshop expands on how to use functions effectively in your code and gives a more formal introduction to functional programming. 

R is a functional programming language, when you run a command on some data, e.g. `sum(1, 2)`, sum is a function, basically everything you do in R involves at least one function. Just as the base R language and other R packages contain functions, you can also write your own functions to perform various tasks using the same tools as package developers, and it's not as hard as it sounds. 

<a name="function"></a>

## 2. Building a simple function 

First, let's import some data that we can use to test the function on:

```r
trees_bicuar <- read.csv("trees_bicuar.csv")
trees_mlunguya <- read.csv("trees_mlunguya.csv")
```

The data contains information on tree stems surveyed in four 1 Ha plots at fieldsites around southern Africa. `trees_bicuar` contains data for trees in Bicuar National Park in southwest Angola, and `trees_mlunguya` contains data for trees in southern Mozambique. Each tree stem >5 cm trunk diameter was measured for tree height and trunk diameter, and identified to species. 

Have a look at the contents of `trees_bicuar` before we move on:

```r
head(trees_bicuar)
str(trees_bicuar)
```

The basic syntax for creating a function looks like this:

```r
name.fn <- function(x, y){
    # Perform an action using x and y
    x + y
}
```

The `function()` is used to tell R that we are creating a function, and we are assigning the function to an object called `name.fn`. `x` and `y` are "arguments" for the function, i.e. things that the user provides when running the function, then in the square brackets are the actions performed by the function, using the parameters defined by the user earlier in the function call, in this case adding `x` and `y` together.

Run the code above to create the function, then test the function:

```r
name.fn(x = 1, y = 2)
```

You should get an output of 3, because the function `name.fn()` was provided with the values of `x = 1` and `y = 2`, which were then passed to the function, which performed the operation `x + y`. Note that the convention is to name a function using `.` rather than `_` which is normally used to define data objects. This isn't a rule, but it's best to stick to the conventions used by other programmers to keep things consistent.

`name.fn()` is a very simplistic function, let's get more complicated by defining a function that calculates the basal area of each stem in m^2 from the diameter, which is in cm.

```r
basal.area <- function(x){
	(pi*(x)^2)/40000
}
```

This function has one input, `x`. `x` can be a numeric vector, or a numeric column in a dataframe. The body of the function multiplies x^2 by pi, then divides by 40,000, giving the basal area as an output. 

Test the function by supplying the diameter column from the Bicuar tree stem data (`trees_bicuar$diam`) to see what the output is:

```r
basal.area(trees_bicuar$diam)
```

Function variables don't need to be `x` and `y`, they can be any character string, for example, the function below works identically to the one above, only `x` is now referred to as `dbh`:

```r
basal.area <- function(dbh){
	(pi*(dbh)^2)/40000
}
```

Just like a normal function, the output of `basal.area()` can be assigned to a new object, for example, as a new column in `trees_bicuar`:

```r
trees_bicuar$ba <- basal.area(trees_bicuar$diam)
```

Writing functions for simple operations like this one is useful if you want to perform the same operation multiple times throughout a script and don't want to copy and paste the same code (e.g. `(pi*(dbh)^2)/40000`) multiple times, this reduces the chances that you will make a typo when copying and pasting.

<a name="loop"></a>

## 3. Functions in loops 

We've seen how to write a function and how they can be used to create concise re-usable operations that can be applied multiple times in a script without having to copy and paste, but where functions really come into their own is when combined with looping procedures. Loops serve to run the same operation on a group of objects, further minimising the replication of code.

Loops come in two main variants in R, `for()` loops and `while()` loops. In this workshop we will focus on `for()` loops, which are generally easier to read than `while()` loops, and can be used to perform the same sorts of actions.

A `for()` loop iterates through a number of items, most commonly stored as a list, and performs some action equally on each item. It can drastically reduce the amount of copying and pasting.

The basic syntax for creating a `for()` loop looks like this:

```r
for(i in list){
    # PERFORM SOME ACTION
}
```

Imagine you have multiple fieldsites, each with four 1 Ha plots with the tree stem measurements described earlier. The data for each fieldsite is contained in a different dataframe, e.g. `trees_bicuar` and `trees_mlunguya`. If we wanted to calculate the basal area for all stems at both sites, we could run:

```r
trees_bicuar$ba <- basal.area(trees_bicuar$diam)
trees_mlunguya$ba <- basal.area(trees_mlunguya$diam)
```

The above seems fine for now, but what if we had 100 fieldsites instead of just two? In that case, I'd recommend a `for()` loop. First, we have to create a list of dataframes to perform the loop on. There are many ways of doing this, but the simplest way is:

```r
trees <- list("trees_bicuar" = trees_bicuar, "trees_mlunguya" = trees_mlunguya)
```

This makes a list called `trees`, where each element in the list is a dataframe. List items within a list can be accessed using double square brackets, e.g. `trees[[1]]` selects the first list item, the dataframe for `trees_bicuar`.

We can take advantage of the method of list indexing using square brackets when we construct our `for()` loop:

```r
for( i in 1:length(trees) ){
	trees[[i]]$ba <- basal.area(trees[[i]]$diam)
}
```

The first line sets up the loop, similar to how the `function()` definition worked earlier. `1:length(trees)` creates a sequence of integers from 1 to the length of the list called `trees`, so in this case the sequence will be `1, 2` as there are two list items. `i` will take each value of `1:length(trees)` in turn, then run the actions in the curly brackets once. For example, the first time the loop runs, `i` will have a value of `1`, and the second time `i` will have a value of `2`. Once the loop has run for the second time, the loop will end, as there are no further values in `1:length(trees)`. 

The body of the loop creates a new column in a dataframe in the list, then runs the function `basal.area()` using the `diam` column from the same dataframe as the input. So, the first time the loop runs, it will create a new column called `ba` in the first list item in `trees`, `trees[[1]]`.

Often, data are not separated into multiple dataframes from the beginning, instead they are often in a single dataframe with a column to group the different datasets. 

Returning to the `trees_mlunguya` dataset, you can see that there is a column called `year`, which denotes when each stem measurement was taken. Imagine we wanted to perform the basal area calculation on each year in the dataset, then find out whether the mean basal area of stems in the plots had changed over the years. We can do this using a `for()` loop.

First, separate `trees_mlunguya` into dataframes in a list based on the year column:

```r
trees_mlunguya_list <- split(trees_mlunguya, trees_mlunguya$year)
```

Then, run a `for()` loop to fill an empty list with the mean basal area of each year:

```r
# Create an empty list
mean_ba_list <- list()

for( i in 1:length(trees_mlunguya_list) ){
	ba <- basal.area(trees_mlunguya_list[[i]]$diam)
	mean_ba <- mean(ba)
	year <- mean(trees_mlunguya_list[[i]]$year)
	dat <- data.frame(year, mean_ba)
	mean_ba_list[[i]] <- dat
}
```

During each iteration, this loop creates a number of intermediate data objects, and eventually returns a dataframe (`dat`) with a single row and two columns, one for year and one for mean basal area. Each of these dataframes are then stored as a list item in the list `mean_ba_list`. 

Of course, all this intermediate calculation could be stored in it's own function:

```r
ba.mean.year <- function(dbh, year){
	data.frame(mean_ba = mean(basal.area(dbh)),
		year = mean(year))    
}

ba.mean.year(trees_mlunguya_list[[1]]$diam, trees_mlunguya_list[[1]]$year)
```

And this new function can be used in the for loop:

```r
for( i in 1:length(trees_mlunguya_list) ){
	mean_ba_list[[i]] <- ba.mean.year(
		trees_mlunguya_list[[i]]$diam,
		trees_mlunguya_list[[i]]$year)
}
```

Note that this `for()` loop now contains a custom function (`ba.mean.year()`), which itself contains a custom function (`basal.area()`), demonstrating that there is really no limit to the complexity you can create with functional programming tools like loops and function calls. You can even have loops within loops, and loops in functions!. 

<a name="apply"></a>

## 4. Functions with the `apply` family 

`for()` loops are very useful for quickly iterating over a list, but because R prefers to store everything as a new object with each loop iteration, loops can become quite slow if they are complex, or running many processes and many iterations. As an alternative `lapply()` and the `apply` family of functions more broadly can be used as an alternative to loops. `lapply()` runs operations of lists of items, as seen in the `for()` loops above. To replicate the previous `for()` loop, where we calculated the mean basal area per year in `trees_mlunguya`, you can run:

```r
lapply(trees_mlunguya_list, function(x) {ba.mean.year(dbh = x$diam, year = x$year)})
```

The first argument of `lapply()` gives the list object to be iterated over. The second argument defines an unnamed function, where `x` will be replaced with each list item as `lapply()` iterates over them. The code inside the curly brackets is the unnamed function, which itself contains our custom function `ba.mean.year()`.

As well as being slightly faster than the `for()` loop, arguably, lapply is also easier to read than a `for()` loop.


<a name="ifelse"></a>

## 5. Conditional statements 

Another useful addition to 

<a name="debug"></a>

## 6. Debugging functions 

As you have seen, functions can get quite complicated, with conditional statements, internal loops, and so on. If you make a mistake while writing a function, the most common result is that RStudio will halt the function and open 


## Tutorial outcomes:

- __TUTORIAL OUTCOMES__


## Further reading

[Advanced R by Hadley Whickham - Functional Programming](http://adv-r.had.co.nz/Functional-programming.html)

<hr>
<hr>

<h3><a href="SURVEY_MONKEY_LINK" target="_blank">&nbsp; We would love to hear your feedback, please fill out our survey!</a></h3>
<br>
<h3>&nbsp; You can contact us with any questions on <a href="mailto:ourcodingclub@gmail.com?Subject=Tutorial%20question" target = "_top">ourcodingclub@gmail.com</a></h3>
<br>
<h3>&nbsp; Related tutorials:</h3>
{% for post in site.posts %}
	{% if post.url != page.url %}
  		{% for tag in post.tags %}
    			{% if page.tags contains tag %}
<h4><a style="margin:0 padding:0" href="{{ post.url }}">&nbsp; - {{ post.title }}</a></h4>
  			{% endif %}
		{% endfor %}
	{% endif %}
{% endfor %}
<br>
<h3>&nbsp; Subscribe to our mailing list:</h3>
<div class="container">
	<div class="block">
        <!-- subscribe form start -->
		<div class="form-group">
			<form action="https://getsimpleform.com/messages?form_api_token=de1ba2f2f947822946fb6e835437ec78" method="post">
			<div class="form-group">
				<input type='text' class="form-control" name='Email' placeholder="Email" required/>
			</div>
			<div>
                        	<button class="btn btn-default" type='submit'>Subscribe</button>
                    	</div>
                	</form>
		</div>
	</div>
</div>

<ul class="social-icons">
	<li>
		<h3>
			<a href="https://twitter.com/our_codingclub" target="_blank">&nbsp;Follow our coding adventures on Twitter! <i class="fa fa-twitter"></i></a>
		</h3>
	</li>
</ul>
