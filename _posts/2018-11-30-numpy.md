
---
layout: post
title: Numbers on Python with Numpy
subtitle: How to deal with arrays of numbers
date: 2019-03-26 00:00:00
author: Ed C
meta: "PythonBasics"
tags: python
---
<div class="block">
  <center><img src="{{ site.baseurl }}/img/tutheader_python.jpg" alt="Img"></center>
</div>

### Tutorial aims:

#### <a href="introduction"> 1. What is NumPy?</a>

#### <a href="basic"> 2. Basic manipulation NumPy arrays</a>

#### <a href="mask"> 3. Masked arrays</a>

#### <a href="io"> 4. Reading and writing data</a>

#### <a href="cautions"> 5. Cautions when using NumPy arrays</a>


<a name="introduction"></a>

## What is NumPy?

So what is NumPy? According to the official website, NumPy is the fundamental package for scientific computing with Python. One caveat of Python is its speed. On the other hand, C is known for its speed. Hence, the developers came to a conclusion of writing a package of numerical functions written in C, and call them from Python. So, without having to learn C, you can use its power.

The biggest advantage is its ability to handle numerical arrays. For example, if you have a list of values you want to square, the code in core Python will look like:
```python
a = [1, 2, 3, 4, 5]
b = []
for i in a:
    b.append(a**2)
```
and you will get `[1, 4, 9, 16, 25]` for `b`. Now, if you want two dimensional array, you have:
```python
a = [[1, 2], [3, 4]]
b = [[],[]]
for i in range(len(a)):
    for j in range(len(a[i])):
        b[i].append(a[i][j]**2)
```
to get `b` equal to `[[1, 4], [9, 16]]`. I would not go into 3 dimensional arrays, as it would be another for loop. Now with numpy you can do same thing with just 1 line for both situations:
```python
import numpy as np

b = np.array(a)**2
```
The execution time is much faster as we do not have the Python's own for loop overhead, or the computational resources required to perform the for loop, but more importantly, you as the coder have to spend much much less time to get what you want to do. Not only that, if your friend has a look at your code, he/she will read the code and understand you want a squared value of the array in an instant, without having to decipher what the for loop is trying to do.

NumPy serves as the basis of most scientific packages in Python, including pandas, matplotlib, scipy, etc. Hence, it would be a good idea to explore the basics of data handling in Python with NumPy. This tutorial does not come with any pre-written files, but is a follow-along tutorial. So better start typing on your IDE or IPython.

<a name="basic"></a>

## Basic manipulation numerical arrays

### Importing the package.
So let us get started. If you have the NumPy installed, you would have to import it.
```python
import numpy as np
```
This is a standard import statement, which uses the syntax `import pacakge as alias`. This allows us to call NumPy with `np`, instead of having to keep typing the whole `numpy`. The same syntax can be used with other modules such as `import pandas as pd`. Most people use this import statement for NumPy.

### Creating NumPy arrays
Creating arrays in numpy is quite easy depending on your requirements.
```python
a = np.full((5, 6), 10.0)
b = np.ones((2, 2, 2))
c = np.zeros(3)
for i in [a, b, c]:
    print(i)
```
These are simple ways create array filled with certain value. The first will be an array with 5 rows and 6 columns all filled with 10.0. The second is a 3d array with each dimension having the size of two, and all values are 1.0. The last is a 1d array containing 3 zeroes.

One can create arrays by creating a 1d array, and reshaping them.
```python
a = np.arange(9.0).reshape(3,3)
print(a.shape)
```
`a` will be a 3 by 3 array [[0., 1., 2.], [3., 4., 5.], [6., 7., 8.]]. The print statement should return a tuple (3, 3).

You can repeat (repeat each element x times) or tile (repeat all elements x times) an array, not surprisingly, using np.repeat and np.tile.

### Accessing and slicing data
Accessing NumPy array is straight-forward.
```python
a = np.arange(30.),reshape(3, 10)
print(a[0])
# index from the back
print(a[-1])
# which should be same as:
print(a[29])
```
The print statement should return the first row of the array, which should be `[0., 1., 2.]`. In Python, counting starts from 0, so `a[1]` will give you the second row instead of the first.

If you are from another language such as IDL, Matlab, Fortran, etc., you would have expected the result of the above code to slice columns of the array. The difference comes in the fact that NumPy uses C style arrays, where the most rapidly changing index comes last. In this case, rows are the least rapidly changing index, hence the slice is made on the row.

For those unfamiliar with the term, there are 2 types of arrays in computing: C and Fortran style arrays. This is basically how each element of an array are linearly allocated in memory. For 2d array, the former will store the array row by row in a long line, while latter stores the data column by column. When accessing the element on the ith row and jth column in a 2d array `x`, you would use `x[i, j]` in C style arrays and `x[j, i]` in Fortran style arrays. Having said this, NumPy arrays from Pandas DataFrame are Fortran-styled. So it is a good practice to check whether your data is C or Fortran styled arrays if you decide to use both NumPy and Pandas as it could give you wrong output. You can use `ndarray.flags.c_contiguous` which will return `True` if the data is C styled.

Going back to NumPy, you can select range of rows using:
```python
a = np.arange(30.),reshape(3, 10)
# select rows 11 to 20
print(a[10:20])

# select rows from start to 10
print(a[:10])
# which should be same as:
print(a[0:10])

# select rows from 20 to last
print(a[20:])
# which should be same as:
print(a[20:30])
```

Now that we explored how to slice rows, let us slice columns.
```python
a = np.arange(30.),reshape(3, 10)
# select second column
print(a[:, 1])
# select columns 1 (second) and 2 (third)
print(a[:, 1:3])
```
`:` on its own stands for select all in this dimension. So, you are in effect selecting all rows, then select first values of each row. If you have been following the tutorial so far, you should now know that if you want to access values in a 3d array, you would use `x[i, j, k]`. Now consider the following script.
```python
# create 3d array with dimensions (time, latitude, longitude)
a = np.zeros((3, 3, 3))
# create 4d array with dimensions (time, height, latitude, longitude)
b = np.zeros((3, 3, 3, 3))

# add 1 to the first columns
a[:, :, 0] += 1.
b[:, :, :, 0] += 1.
```
If you are dealing with atmospheric data, you would often find you would be dealing with both 3d and 4d variables. If you would like to modify all points at certain longitudes (columns), you could write them explicitely as above. Or you could write a loop like below where you execute different command depending on the dimension of the array:
```python
# create 3d array with dimensions (time, latitude, longitude)
a = np.zeros((3, 3, 3))
# create 4d array with dimensions (time, height, latitude, longitude)
b = np.zeros((3, 3, 3, 3))

# add 1 to the first columns
for i in [a, b]:
    dimensions = len(i.shape)
    if dimensions == 3:
        i[:, :, 0] += 1.
    elif dimensions == 4:
        i[:, :, :, 0] += 1.
```
Well, while there is nothing wrong with this code, we have a better method:
```python
# create 3d array with dimensions (time, latitude, longitude)
a = np.zeros((3, 3, 3))
# create 4d array with dimensions (time, height, latitude, longitude)
b = np.zeros((3, 3, 3, 3))

# add 1 to the first columns
for i in [a, b]:
    i[..., 0] += 1.
```
`...` is called the ellipsis, and it is used to select all unspecified dimensions.

NumPy has more slicing options, such as striding (e.g. select every other rows) and select multiple points at a time using fancy indexing. Or you can pass a Boolean array (array containing `True` and `False`) to select values and create 1d array with them.
```python
# get every other row
a = np.arange(27., 0., -1).reshape(9, 3)
print(a[::2])

# get diagonal values in the 5x5 array using fancy indexing
b = np.arange(25).reshape(5, 5)
print(b[[0, 1, 2, 3, 4],[0, 1, 2, 3, 4]])

# use Boolean array to create 1d array of selection
c = np.array([[0., 1., 2.], [2., 3., 4.]])
d = np.array([[True, False False], [False, True, True]])
print(c[d])

# create and use the Boolean array to selectively change data
e = np.arange(9.).reshape(3, 3)
f = e>5  # select values greater than 5.0
e[f] = 10.  # make all values greater than 5.0 to 10.0
print(e)
# or you can simply do
e = np.arange(9.).reshape(3, 3, 3)
e[e>5] = 10.0
```
<a name="mask"></a>

## Masked Arrays

Supposedly you have a time series with missing data, and want to perform the row sum.
```python
a = np.array([np.nan, , 3., 1.], [2., 8., 5.])
print(np.sum(a, axis=1))
```
What is the result? While the second sum comes out as 14.0, the first would just give you `nan`, which stands for "not a number". We need to make Python to ignore this invalid value.
```python
a = np.array([np.nan, , 3., 1.], [2., 8., 5.])
print(np.sum(np.ma.masked_invalid(a), axis=1))
```
Now we get 4.0 and 14.0. Another common reason to mask the data is to get rid of some values not fit for purpose. For example, if you are studying the damages caused by earthquakes in a region using historic data, and decide you want the sum of losses of the events with magnitude greater than 5.0. You can simply do:
```python
magnitude = np.array([2., 5., 6., 1.])
damage = np.array([1000., 100000., 110000, 10.])
print(np.sum(np.ma.masked_where(magnitude>=5.0, damage)))
```
This should give you 210,000.
There are numerous ways to mask your data for different purposes. All the available methods are listed under <a href="https://docs.scipy.org/doc/numpy/reference/maskedarray.generic.html" target="_blank">`numpy.ma` documentation</a> in the web.
<a name="io"></a>

## Reading and writing data

With standard .csv files, there are number of methods that lets you read data file. While the shortest way is to use `np.genfromtxt()` function, my personal favourite is to use Pandas to read it and then convert it to pure NumPy arrays.
```python
import numpy as np
import pandas as pd

# read file as pandas.DataFrame then get values
data = pd.read_csv('your_csv_file').values
# convert Fortran style array to C style array
data = np.ascontiguousarray(data)
```
When writing the data to file, I use `np.savetxt` with `delimeter=','` option, or `pandas.DataFrame.to_csv`.
```python
# save csv file using numpy
np.savetxt('save_file.csv', your_data, delimeter=',', comments='')
```
The choice of tool is entirely up to you. The biggest reason why I tend to read csv data with Pandas is because the `np.genfromtxt()` often messes up the string/integer/float format of the data, and setting them up manually can be a bit messy.

If you just want to store data, and it does not matter whether it is human-readable or not, you can choose to use the NumPy binary format.
```python
# save one data to npy file
np.save('save_file1.npy' ,data)
# save collection of data to single npz file
dataset = {'temperature': data1,
		   'humidity': data2}
np.savez('save_file2.npz', **dataset)

# reopen files
open_data = np.load('save_file1.npy')
open_dataset = np.load('save_file2.npz')
# access data in dataset
temperature = open_dataset['temperature']
```
There would be number of packages available to allow you to open files of different formats into NumPy arrays (e.g. `netCDF4` for netCDF files).

<a name="cautions"></a>

## Cautions when using NumPy

Some of you (with some experience in core Python) might have felt something is not quite right. The culprit might be the fact that we have been able change the values of the original arrays within loops, which is not the default behaviour of Python!

Consider the following code:
```python
c = 1.
d = c
# add 1 to d 5 times
for i in range(5):
    d += 1.  # d = d + 1
print(c, d)
```
As expected, the print statement will return `(1., 6.)`.

Now consider the code below.
```python
c = np.arange(3.)  # array containing [0., 1., 2.]
d = c
# add 1 to d 5 times
for i in range(5):
    d += 1.  # d = d + 1
print(c, d)
```
You must be expecting the answer to be `[0., 1., 2.] [5., 6., 7.]`. But no, both of them comes out as `[5., 6., 7.]`. You should be asking why `c` is changed when you specified it is `d` that changes. Well, the answer is that the `c = ndarray` statement creates an array in memory and assigns `c` with its id to access it. So when you did `d = c`, you essentially copied the id, not the actual array in memory. The code should look like the following to do what you "expect" it to do.
```python
c = np.arange(3.)  # array containing [0., 1., 2.]
d = c.copy()
# add 1 to d 5 times
for i in range(5):
    d += 1.  # d = d + 1
print(c, d)
```
`ndarray.copy()` will copy the array itself and produce the result you want.

So, what good does this behaviour bring? Well, consider the following scenario. You have two different arrays, and want to add 1 to all of their elements. If the array creates a copy by default, you cannot use loops like the following:
```python
e = np.ones(3)
f = np.zeros(3)
for i in [e, f]:
    i = i + 1
    print(i)
print(e, f)
```
The output of this code will give you no change to the values of e and f, if true copy of array is made and allocated to `i`. Instead, you would need two lines of same code to achieve it.
```python
e += 1
print(e)
f += 1
print(f)
```
This is only a simple illustration. But if you have large datasets with identical properties and want to perform same operations before comparing them, this property becomes very handy.

# Summary

As a scientific computing tool, Python is a powerful tool, with NumPy at its heart. This tutorial hopefully would have helped people to start in their quest of using numerical analysis with Python, through introducing how to NumPy arrays work and how to access elements in the arrays.

### Tutorial outcomes:

#### 1. You would roughly know what NumPy is used for.

#### 2. You can walk through NumPy arrays using slicing

#### 3. You can create simple masks on data to ignore some of the entries

#### 4. You can read data to and write data in NumPy array format

#### 5. You know how dealing with NumPy objects might be different from other Python objects

<hr>
<hr>

<h3><a href="SURVEY_MONKEY_LINK" target="_blank">&nbsp; We would love to hear your feedback, please fill out our survey!</a></h3>
<br>
<h3>&nbsp; You can contact us with any questions on <a href="mailto:ourcodingclub@gmail.com?Subject=Tutorial%20question" target = "_top">ourcodingclub@gmail.com</a></h3>
<br>
<h3>&nbsp; Related tutorials:</h3>
{% for post in site.posts %}
	{% if post.url != page.url %}
  		{% for tag in post.tags %}
    			{% if page.tags contains tag %}
<h4><a style="margin:0 padding:0" href="{{ post.url }}">&nbsp; - {{ post.title }}</a></h4>
  			{% endif %}
		{% endfor %}
	{% endif %}
{% endfor %}
<br>
<h3>&nbsp; Subscribe to our mailing list:</h3>
<div class="container">
	<div class="block">
        <!-- subscribe form start -->
		<div class="form-group">
			<form action="https://getsimpleform.com/messages?form_api_token=de1ba2f2f947822946fb6e835437ec78" method="post">
			<div class="form-group">
				<input type='text' class="form-control" name='Email' placeholder="Email" required/>
			</div>
			<div>
                        	<button class="btn btn-default" type='submit'>Subscribe</button>
                    	</div>
                	</form>
		</div>
	</div>
</div>

<ul class="social-icons">
	<li>
		<h3>
			<a href="https://twitter.com/our_codingclub" target="_blank">&nbsp;Follow our coding adventures on Twitter! <i class="fa fa-twitter"></i></a>
		</h3>
	</li>
</ul>
